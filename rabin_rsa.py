import gmpy2
from Crypto.Util.number import *

e = 2
c=44672125665979746187022088487287549148143682914366860697256607123781682388661134720376815356776762660865148273332405351472399646497461244873917009600249493567836374853148085611514506308693392828759662814656597749775400588251246138775054464374432452292004323598707522226227586505604237344275146563551115841743
n=170813881629246718089558943285403963046165498115460534102073197324160828215616441850294542892978016909352720239324757076517038997286413982272818205282051491746686039105669222890466100723377271607756487000837132352170050403170972192423505839737696311632004375609511311367620143335896629889718664132886463866897

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

sq,b = gmpy2.iroot(n,2)
while n%sq != 0:
    sq += 1
p = sq
q = n // sq

print(p%4)
print(q%4)
print(p*q==n)



phi = (p-1)*(q-1)
d = inverse(e,phi)
print(d)
print(long_to_bytes(pow(c,d,n)))
g ,yp, yq = egcd(p,q)
mp = pow(c,(p+1)//4,p)
mq = pow(c,(q+1)//4,q)

r = (yp*p*mq + yq*q*mp) % n
mr = n - r
s = (yp*p*mq - yq*q*mp) % n
ms = n - s
for num in [r,mr,s,ms]:
    print(long_to_bytes(num))
